# Use an official lightweight Python image.
# alpine is smaller, but slim is more compatible with binary extensions if you need them
FROM python:3.8-slim

# Set environment variables.
# Python won't try to write .pyc files on the container
ENV PYTHONDONTWRITEBYTECODE 1
# Python outputs everything directly to the terminal (e.g. docker logs) so that it can be observed in real-time
ENV PYTHONUNBUFFERED 1
# Define the directory where the app will be placed. This is the directory where your code lives in the Docker container.
WORKDIR /usr/src/app

# Install system dependencies.
# This includes dependencies that are required for your application to run, like gcc, libpq-dev for PostgreSQL client, etc.
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    libpq-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Install ffmpeg for moviepy if needed, this might not be necessary for all Flask applications.
RUN apt-get update && apt-get install -y ffmpeg \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Copy the current directory contents into the container at /usr/src/app
# Copy only the requirements.txt initially for better cache on rebuilds
COPY requirements.txt ./

# Install any needed packages specified in requirements.txt
# This is done before copying the entire project to cache the installed dependencies.
RUN pip install --no-cache-dir -r requirements.txt

# Now copy in the rest of your code
# This layer will be rebuilt every time you update your application's code.
COPY . .

# Make port 80 available to the world outside this container.
# This should be the same as in the EXPOSE directive in your Dockerfile for Heroku.
EXPOSE 80

# Define environment variable for gunicorn to listen on port 80
ENV PORT=80

# Use gunicorn as the entrypoint. Adjust the workers/threads according to your needs.
# You can also use other WSGI servers like uWSGI or waitress.
CMD ["gunicorn", "--bind", "0.0.0.0:${PORT}", "--workers", "3", "app:app"]
